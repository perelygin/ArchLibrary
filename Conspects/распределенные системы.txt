Бёрнс Б.  Распределенные системы. Паттерны проектирования

Глава 1
Мгновенное масштабирование сервиса - распределенная система(РП).
РП состоит из нескольких  разных приложений или из нескольких копий одного приложения на разных машинах. Взаимодействуя они реализуют некий сервис.
РП более надежны,  легко масштабируются,  команда разработчиков тоже легко масштабируется. 
Но РП сложнее в разработке.
Паттерны РП - это обобщенные схемы организации распределенных систем, которые не звисят от конкретных технологий или приложений.
Ценность паттернов:
 - обучение на чужих ошибках
 - Общий словарь
 - повторное исползование кода(в виде контейнеров)
 
*Часть I
Одноузловые паттерны проектирования(pods в Kubernetis)
 Разделение по контейнерам диктуется разными требованиями приложений к ресурсам. Критичные по времени в отдельный контейнер с большой памятью и т.д.
 На каждый контейнер можно посадить отдельную команду. Небольшие приложения более понятны
 Одноузловые паттерны подразумевают тесную связь между всеми контейнерами. В частности, они предполагают, что исполнение контейнеров в паттерне может 
 быть надежно распланировано в рамках одной машины. Они также подразумевают, что все контейнеры в рамках паттерна могут при необходимости совместно 
 использовать тома или части файловых систем, а также иные ключевые ресурсы, например сетевые пространства имен и общую память.

**Глава 2  Паттерн Sidecar(34)
это одноузловой паттерн из двух контейнеров. 
Контейнер приложения и прицеп,  который используется чтобы добавить функциональности контейнеру. 
Делается в одном поде.Совместноиспользуют  процессоры, файловые, сетевые ресурсты хоста.
Одно из основных преимуществ применения паттерна Sidecar — модульность и повторное использование контейнеров-прицепов.
***Пример 1: модернизация унаследованных приложений. 
	Старое приложение, помещенное в контейнер. Технологии сборки утеряны. Нужно перевести обмен с HTTP на HTTPS.
	При использовании паттерна Sidecar к контейнеру с приложением добавляется контейнер-прицеп с веб-сервером nginx. 
	Nginx-контейнер находится в том же пространстве имен, что и унаследованное веб-приложение, поэтому ему доступен сервис,
	работающий на localhost. В то же время nginx позволяет обслуживать HTTPS-трафик, приходящий с внешнего адреса группы контейнеров, 
	и проксировать его унаследованному веб-приложению.
	
***Пример 2: Синхронизация конфигурации.
	В изначально облачной среде полезнее использовать API для обновления конфигурации приложения.
	Если есть старое приложение,  для которого нужно обеспечить обновление конфигурации. 
	два контейнера — контейнер, предоставляющий услуги приложения, и контейнер с менеджером конфигурации. 
	Два контейнера объединены в под, в котором они совместно используют каталог. В этом совместно используемом 
	каталоге и находится конфигурационный файл. Унаследованное приложение при запуске предсказуемо загружает 
	конфигурацию из файла в файловой системе. Менеджер конфигурации при запуске считывает данные конфигурационного
	API и ищет различия между файловой системой и сохраненной посредством API конфигурацией. При обнаружении 
	различий менеджер конфигурации загружает новые настройки в конфигурационный файл локальной файловой системы
	и уведомляет унаследованное приложение, что ему необходимо повторно считать конфигурацию.
	
***Пример 3: Реализация контенера прицепа для интроспекции за приложением. 
	функционал, касающийся отладки и управления приложением, например считывание ресурсов, потребляемых приложениями внутри контейнера.
	Topz-контейнер осуществляет интроспекцию всех запущенных процессов и предоставляет единообразный пользовательский интерфейс.
	
***Параметризованные контейнеры
	Параметризация контейнеров — важнейший показатель достижения модульности и повторного использования контейнеров, 
	независимо от того, реализуют они паттерн Sidecar или нет. Контейнер-прицеп с SSL, который мы развернули ранее. 
	Чтобы быть полезным в общем случае, он должен иметь по меньшей мере два параметра: имя сертификата, обеспечивающего функциональность 
	SSL, и порт унаследованного сервера приложений, запущенного на локальной машине. Параметры контейнеру можно передавать двумя 
	способами — через переменные среды или через командную строку(docker run -e=PORT=<порт> -d <образ>).

***Определение API всех контейнеров
	Микроконтейнеры рассчитывают на наличие некоторого программного интерфейса, который бы четко разделил основное приложение и 
	контейнер-прицеп

***Документирование контейнеров
	Мало пользы в создании гибкого, надежного, модульного контейнера, если никто не может понять, как с ним работать. 
	Хорошо бы писать комментарии в  dockerfile
	
**Глава 3. Паттерн Ambassador
Посредник во взаимодействии контейнера-приложения с внешним миром.

***Шардирование(когда хранилище разделено на несколько частей)
	При адаптировании существующего приложения к шардированному хранилищу мы создаем контейнер-посол, который содержит всю необходимую 
	логику для переадресации запросов соответствующим шардам хранилища. Таким образом, программное обеспечение клиентского или промежуточного 
	уровней подключается к сервису, который выглядит как единое хранилище, работающее на локальной машине. Но этот сервис на самом деле является 
	шардирующим прокси-контейнером, реализующим паттерн Ambassador. Он принимает запросы от приложения, переадресует их соответствующему шарду 
	хранилища и затем возвращает результат приложению.

*** Сервис-посредник
	Когда нужно обеспечить переносимость приложения между разными средами  основной проблемой становится обнаружение и конфигурирование сервисов.
	Например, конфигурация лежит в неком контейнере с MySQL. Следовательно, переносимое приложение должно иметь возможность изучить свое окружение
	и найти подходящий MySQL-сервер. Такой процесс называется обнаружением сервисов (service discovery), а система, которая выполняет обнаружение 
	и стыковку, называется сервисом-посредником (service broker),  который и реализуется с помощью паттерна Ambassador
	
*** Для проведения экспериментов и разделения запросов
	Как и ранее, контейнер приложения просто подключается к сервису, работающему на локальном компьютере. Контейнер-посол, в свою очередь, получает 
	запросы, проксирует их как рабочей, так и экспериментальной системам, а затем возвращает ответы рабочей системы так, как будто сам сделал всю работу.
	
** Глава 4.  Адаптеры
Контейнер-адаптер модифицирует программный интерфейс контейнера приложения таким образом, чтобы он соответствовал некоему заранее определенному интерфейсу,
реализация которого ожидается от всех контейнеров приложений.

***Мониторинг
Применительно к мониторингу мы видим, что контейнер приложения — это просто приложение, за которым мы хотим наблюдать.
Контейнер-адаптер содержит инструменты, преобразующие интерфейс мониторинга, предоставляемого контейнером приложения, 
в интерфейс, ожидаемый системой мониторинга общего назначения.
	
***Ведение журналов
	Контейнер приложения может вести журнал в файле, а контейнер-адаптер будет перенаправлять его содержимое в поток stdout. Разные контейнеры приложения
	могут вести журналы в разных форматах, а контейнер-адаптер может преобразовывать эти данные в общее структурированное представление, 
	которым сможет воспользоваться агрегатор журналов.
	
***Мониторинг работоспособности сервисов
База данных работает в контейнере приложения, который имеет общий с контейнером-адаптером сетевой интерфейс. Контейнер-адаптер — простой контейнер, 
который содержит только сценарий оболочки, оценивающий работоспособность базы данных. Если контейнер приложения когда-либо не пройдет проверку,
он будет автоматически перезапущен

*Часть II  Паттерны проектирования обслуживающих систем
Микросервисы - это круто. Но  системы на их основе сложно отлаживать.  Потому что Любая ошибка оказывается следствием того, что большое количество 
систем работает на большом количестве машин. Такую среду сложно воспроизвести в отладчике.

**Глава 5 Реплицированные сервисы с распределением нагрузки
В рамках такого сервиса все серверы идентичны друг другу и поддерживают входящий трафик. Паттерн состоит из масштабируемого набора серверов, находящихся 
за балансировщиком нагрузки. Балансировщик обычно распределяет нагрузку либо по карусельному (round-robin) принципу, либо с применением некоторой 
разновидности закрепления сессий.

*** Сервисы без внутреннего состояния(stateless-сервисы)
не требуют для своей работы сохранения состояния. Масштабируются  путем добавления второй и т.д. копий сервиса через  балансировщик нагрузки. 
При этом отдельные запросы могут быть направлены разным экземплярам(копиям) сервиса. Паттерн Load-balanced Replicated Serving (обслуживание 
с репликацией и балансировкой нагрузки).

***Датчики готовности для балансировщика нагрузки
Датчик готовности определяет, готово ли приложение обслужить запрос пользователя. Нужно предусмотреть специальный URL, реализующий проверку готовности.

***Сервисы с закреплением сессий
Направление запросов конкретного пользователя экземпляру сервиса, запущенному на определенной машине. Иногда это обусловлено кэшированием 
пользовательских данных в памяти: если запросы этого пользователя будут попадать на одну и ту же машину, то повысится коэффициент попадания.
Может быть обусловлено долгосрочной природой взаимодействия пользователя с системой, когда часть состояния хранится между запросам
Пока IP-адреса клиента и сервера остаются неизменными, все запросы этого клиента будут адресованы одному и тому же экземпляру сервиса(хэширование 
IP-адресов клиента и сервера).
Консистентаная хэш-функция -  на случай если количество копий сервиса меняется, то может поменяться и соответствие между конкретным пользователем 
и конкретным экземпляром сервиса. Консистентные хеш-функции минимизируют количество пользователей, у которых поменяется сопоставленный им 
экземпляр сервиса.
Плохо работает через NAT. Тогда лучше использовать cookies.

***Сервисы с репликацией на уровне приложения
Если код stateless-сервиса достаточно сложен в вычислительном плане, несмотря на то что состояние сервиса не хранится,  то пригодился бы кэш. Из которого можно  
брать сохраненные в нем web-страницы.
Кэш находится между stateless-приложением и запросом конечного пользователя. Простейшая форма кэширования в веб-приложениях — применение кэширующего веб-прокси.
Развертывание кэширующего сервера - Простейший способ развертывания веб-кэша — рядом с каждым экземпляром сервиса при использовании паттерна Sidecar.
Балансировщик высылает запросы в кэш-сервисы, которые либо сразу направляют кэшированный ответ,  либо перенаправлют его в одну из копий сервиса в соответствии с 
закреплением сессии. 
Недостаток -  кэщ придется реплицировать вместе с приложением. 
Может быть нарушен механизм закрепления сессий. Если используете привязку IP-адресов по умолчанию, все запросы будут отправляться с IP-адреса кэша, а не конечного 
пользователя сервиса. Если вы, развернули небольшое количество кэш-серверов, привязка IP-адресов могла произойти таким образом, что некоторые экземпляры веб-сервиса 
не получают трафика. Вместо привязки сессии к IP следует использовать cookie-файлы или HTTP-заголовки.

***Расширение возможностей кэширующей прослойки 
Обратные HTTP-прокси вроде Varnish обычно имеют возможность расширения и, помимо кэширования, могут предоставлять дополнительные возможности.

****Ограничение частоты запросов и защита от атак типа «отказ в обслуживании» (DoS) -  Когда количество запросов от одного пользователя достигает определенного лимита, сервер 
вернет ему ошибку с кодом 429, означающую превышение количества максимально допустимых запросов.

****SSL-мост
для обеспечения защищенного соединения с клиентами.